// Copyright 2014 Charles Gentry. All rights reserved.
// Please see the license included with this package
//
package request

import (
	"crypto/Header"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"net/http"
	"errors"
	"time"
	"strings"
	. "github.com/cgentry/gvac"
)

/* What is used in the HMAC?
*	A request comes in that looks like
* 	GET	/register/mydomain?login=we_want_you&pwd=password&email=user@something&name=john_doe
*
*
*	The authorisation information must occur in the header:
		Authorization: abcd-efg-1234-456:qnR8UCqJggD55PohusaBNviGoOJ67HC6Btry4qXLVZc=

	The split occurs at the first colon (:). The left is the caller's ID. The right is the hmac
	generated by hashing key values.

	The contents of the headers required for authorisation are:
		* The Client ID (always, and in the Authorization header value)
		* The Content-MD5 header (if there is a body)
		* The Content-Type in the header (if present)
		* Either header contents of Timestamp the standard HTTP header 'Date:' in the request
		* The complete request (/register/mydomain?login....)
		* The client secret (not sent in request) is used as the hash key

	The following should be generated per request:
		Rqst	MD5		Type
		GET		No		No
		PUT		Yes		Yes
		DELETE	No		No
		POST	Yes		Yes
*/



type Secure struct{
	TimeWindow	time.Duration
	user		string
	hmacToken	string
	appPrefix   string
}

func NewServer() * Secure {
	return &Secure{ TimeWindow: 15*time.Minute , appPrefix: `X-Gav-` }
}

/* ===============================================================
 *               PRIVATE FUNCTIONS
 * ===============================================================
 */
func ( s * Secure ) decodeAuth( r * http.Request )error {
	if s.user == "" || s.hmacToken == "" {
		parts := strings.SplitN( r.Header.Get( GAV_HEADER_TOKEN ) , ":" , 2 )
		if len( parts ) < 2 {
			return  errors.New(TOKEN_INCOMPLETE)
		}
		s.user = strings.TrimSpace( parts[0] )
		s.hmacToken = strings.TrimSpace(parts[1])
		if len( s.user ) == 0 || len( s.hmacToken ) == 0 {
			return errors.New( TOKEN_MISSING_PARM)
		}
	}
	return nil
}
func( s * Secure ) getUri( r * http.Request ) string {
	// Reconstitued version
	// The RawURI does not include the fragment so we need to build it here...
	val := r.URL.Path
	if r.URL.RawQuery != "" {
		val = val + `?` + r.URL.RawQuery
	}
	if r.URL.Fragment != "" {
		val = val + `#` + r.URL.Fragment
	}
	return val
}

/* ===============================================================
 *               PUBLIC FUNCTIONS
 * ===============================================================
 */
func ( s * Secure ) GetUser( r * http.Request) ( string , error ){
	err:= s.decodeAuth(r)
	return s.user , err
}

func ( s * Secure ) GetSignature( r * http.Request ) ( string , error ){
	err:= s.decodeAuth(r)
	return s.hmacToken , err
}

func ( s * Secure ) GetAppPrefix( ) string {
	return s.appPrefix ;
}

func ( s * Secure ) SetAppPrefix( pfx string ) * Secure {
	s.appPrefix = pfx
	return s
}

/**
 * Create a signature value from the request, user and secret and body
 */
func ( s * Secure ) CalculateSignature( r * http.Request , user string , secret , body []byte ) ( string , error ){

	if len( secret ) == 0 {
		return "", errors.New( SECRET_INVALID )
	}
	dt, err := s.GetDateString(r)
	if err != nil {
		return "",err
	}
	mac := hmac.New( sha256.New , secret )					// Setup with secret key
	mac.Write( []byte( strings.TrimSpace(user) ) )			// Add in user ID
	mac.Write( []byte( dt))									// Add in DATE
	mac.Write( []byte( CalculateContentMD5(body)))			// Add in the MD5 calculate value
	mac.Write( []byte( r.Header.Get( GAV_HEADER_TYPE )))	// Add in Content-Type from header
	mac.Write( []byte( s.getUri(r)))						// add in the re-constituted URI
	mac.Write( GetAppHeaderValues( r.Header , s.appPrefix))	// Add in all the 'special' headers

	return base64.StdEncoding.EncodeToString(mac.Sum( nil ) ), nil
}

func ( s * Secure ) VerifySignature( r * http.Request , secret , body [] byte ) error {
	if err := s.VerifyContentMD5( r , body ) ; err != nil {
		return err
	}
	if err := s.VerifyDate( r ); err != nil {
		return err
	}

	if signature,err := s.GetSignature(r); err != nil {
		return err
	}else if user, err := s.GetUser( r ); err != nil {
		return err
	}else if computed,err := s.CalculateSignature( r , user , secret , body ); err != nil {
		return err
	}else if ! hmac.Equal([]byte(signature), []byte( computed)){
		return errors.New( SIGNATURE_INVALID)
	}
	return nil
}

func ( s * Secure ) SetSignature( r * http.Request , user string , secret, body []byte) ( err error ) {
	var signature string
	s.SetContentMD5( r , body ).SetDate( r )				// Add CONTENT and DATE to header

	user = strings.TrimSpace( user )						// Fetch user
	if signature , err = s.CalculateSignature( r, user, secret , body); err == nil {
		r.Header.Set( GAV_HEADER_TOKEN , fmt.Sprintf( "%s:%s", user,signature ))
	}
	return err
}
