// Copyright 2014 Charles Gentry. All rights reserved.
// Please see the license included with this package
//
package response

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"net/http"
	"errors"
	. "github.com/cgentry/gvac"
	"strings"
)

/* What is used in the HMAC?
*	A request comes in that looks like
* 	GET	/register/mydomain?login=we_want_you&pwd=password&email=user@something&name=john_doe
*
*
*	The authorisation information must occur in the header:
		Authorization: abcd-efg-1234-456:qnR8UCqJggD55PohusaBNviGoOJ67HC6Btry4qXLVZc=

	The split occurs at the first colon (:). The left is the caller's ID. The right is the hmac
	generated by hashing key values.

	The contents of the headers required for authorisation are:
		* The Client ID (always, and in the Authorization header value)
		* The Content-MD5 header (if there is a body)
		* The Content-Type in the header (if present)
		* Either header contents of Timestamp the standard HTTP header 'Date:' in the request
		* The complete request (/register/mydomain?login....)
		* The client secret (not sent in request) is used as the hash key

	The following should be generated per request:
		Rqst	MD5		Type
		GET		No		No
		PUT		Yes		Yes
		DELETE	No		No
		POST	Yes		Yes
*/


type Secure struct{
	appPrefix   string
}

func NewServer() * Secure {
	return &Secure{  appPrefix: `X-Gav-` }
}


func ( s * Secure ) GetAppPrefix( ) string {
	return s.appPrefix ;
}

func ( s * Secure ) SetAppPrefix( pfx string ) * Secure {
	s.appPrefix = pfx
	return s
}
/*
 * Create a signature value from the request, user and secret and body
 */
func ( s * Secure ) CalculateSignature( w http.ResponseWriter , user string , secret , body []byte ) ( string , error ){

	if len( secret ) == 0 {
		return "", errors.New( SECRET_INVALID )
	}
	dt, err := s.GetDateString(w)
	if err != nil {
		return "",err
	}
	mac := hmac.New( sha256.New , secret )					// Setup with secret key
	mac.Write( []byte( strings.TrimSpace(user) ) )			// Add in user ID
	mac.Write( []byte( dt))									// Add in DATE
	mac.Write( []byte( CalculateContentMD5(body)))			// Add in the MD5 calculate value
	mac.Write( []byte( w.Header().Get( GAV_HEADER_TYPE )))	// Add in Content-Type from header
	mac.Write( GetAppHeaderValues( w.Header() , s.appPrefix))	// Add in all the 'special' headers

	return base64.StdEncoding.EncodeToString(mac.Sum( nil ) ), nil
}

func ( s * Secure ) SetSignature( w http.ResponseWriter , user string , secret, body []byte)( err  error) {
	var signature string
	s.SetContentMD5( w , body ).SetDate( w )				// Add CONTENT and DATE to header

	user = strings.TrimSpace( user )						// Fetch user
	if signature , err = s.CalculateSignature( w, user, secret , body); err == nil {
		w.Header().Set( GAV_HEADER_TOKEN , fmt.Sprintf( "%s:%s", user,signature ))
	}
	return err
}
